.data
	global:
	0 
	str_1: .asciiz "\n"
	str_2: .asciiz "invaild input!\n"
	str_0: .asciiz "gcd is "


.text
		la $28, global
		addiu	 $29, $29, -84

# function_i32 @main():
		f_main:
	# basicBlock_0
		# 	%1 = alloca i32
		# 	%2 = alloca i32
		# 	%3 = call i32 @getint()
		addiu	 $2, $0, 5
		syscall
		xor		 $5, $2, $0
		# 	store i32 %3, i32* %1
		sw		 $5, 4($29)
		# 	br label %4
		j bb_main_4
	# basicBlock_4
		bb_main_4:
		# 	%5 = load i32, i32* %1
		lw		 $5, 4($29)
		# 	%6 = icmp ne i32 %5, -1
		addiu	 $1, $0, 1
		subu	 $1, $0, $1
		sne		 $6, $5, $1
		# 	%7 = icmp ne i1 %6, 0
		# 	br i1 %7, label %8, label %14
		addiu	 $1, $0, 0
		bne		 $6, $1, bb_main_8
		j bb_main_14
	# basicBlock_8
		bb_main_8:
		# 	%9 = call i32 @getint()
		addiu	 $2, $0, 5
		syscall
		xor		 $5, $2, $0
		# 	store i32 %9, i32* %2
		sw		 $5, 8($29)
		# 	%10 = load i32, i32* %1
		lw		 $6, 4($29)
		# 	%11 = zext i1 0 to i32
		addiu	 $7, $0, 0
		# 	%12 = icmp eq i32 %10, %11
		seq		 $8, $6, $7
		# 	%13 = icmp ne i1 %12, 0
		# 	br i1 %13, label %19, label %15
		addiu	 $1, $0, 0
		bne		 $8, $1, bb_main_19
		j bb_main_15
	# basicBlock_14
		bb_main_14:
		# 	ret i32 0
		addiu	 $2, $0, 10
		syscall
	# basicBlock_15
		bb_main_15:
		# 	%16 = load i32, i32* %2
		lw		 $5, 8($29)
		# 	%17 = icmp eq i32 %16, 0
		addiu	 $1, $0, 0
		seq		 $6, $5, $1
		# 	%18 = icmp ne i1 %17, 0
		# 	br i1 %18, label %26, label %21
		addiu	 $1, $0, 0
		bne		 $6, $1, bb_main_26
		j bb_main_21
	# basicBlock_19
		bb_main_19:
		# 	call void @error()
		sw		 $31, 0($29)
		addiu	 $29, $29, -4
		jal f_error
		addiu	 $29, $29, 4
		lw		 $31, 0($29)
		# 	%20 = call i32 @getint()
		addiu	 $2, $0, 5
		syscall
		xor		 $5, $2, $0
		# 	store i32 %20, i32* %1
		sw		 $5, 4($29)
		# 	br label %4
		j bb_main_4
	# basicBlock_21
		bb_main_21:
		# 	%22 = load i32, i32* %1
		lw		 $5, 4($29)
		# 	%23 = load i32, i32* %2
		lw		 $6, 8($29)
		# 	call void @gcd(i32 %22,i32 %23)
		sw		 $5, 64($29)
		sw		 $6, 68($29)
		sw		 $31, 0($29)
		sw		 $5, -104($29)
		sw		 $6, -100($29)
		addiu	 $29, $29, -108
		jal f_gcd
		addiu	 $29, $29, 108
		lw		 $31, 0($29)
		# 	%24 = load i32, i32* @ans
		lw		 $5, 0($28)
		# 	call void @output(i32 %24)
		sw		 $5, 72($29)
		sw		 $31, 0($29)
		sw		 $5, -12($29)
		addiu	 $29, $29, -16
		jal f_output
		addiu	 $29, $29, 16
		lw		 $31, 0($29)
		# 	%25 = call i32 @getint()
		addiu	 $2, $0, 5
		syscall
		xor		 $5, $2, $0
		# 	store i32 %25, i32* %1
		sw		 $5, 4($29)
		# 	br label %4
		j bb_main_4
	# basicBlock_26
		bb_main_26:
		# 	call void @error()
		sw		 $31, 0($29)
		addiu	 $29, $29, -4
		jal f_error
		addiu	 $29, $29, 4
		lw		 $31, 0($29)
		# 	%27 = call i32 @getint()
		addiu	 $2, $0, 5
		syscall
		xor		 $5, $2, $0
		# 	store i32 %27, i32* %1
		sw		 $5, 4($29)
		# 	br label %4
		j bb_main_4

# function_void @gcd(i32,i32):
		f_gcd:
	# basicBlock_2
		# 	%3 = alloca i32
		# 	store i32 %0, i32* %3
		lw		 $5, 4($29)
		sw		 $5, 12($29)
		# 	%4 = alloca i32
		# 	store i32 %1, i32* %4
		lw		 $6, 8($29)
		sw		 $6, 16($29)
		# 	%5 = load i32, i32* %3
		lw		 $7, 12($29)
		# 	%6 = zext i1 0 to i32
		addiu	 $8, $0, 0
		# 	%7 = icmp eq i32 %5, %6
		seq		 $9, $7, $8
		# 	%8 = icmp ne i1 %7, 0
		# 	br i1 %8, label %14, label %9
		addiu	 $1, $0, 0
		bne		 $9, $1, bb_gcd_14
		j bb_gcd_9
	# basicBlock_9
		bb_gcd_9:
		# 	%10 = load i32, i32* %4
		lw		 $5, 16($29)
		# 	%11 = zext i1 0 to i32
		addiu	 $6, $0, 0
		# 	%12 = icmp eq i32 %10, %11
		seq		 $7, $5, $6
		# 	%13 = icmp ne i1 %12, 0
		# 	br i1 %13, label %21, label %16
		addiu	 $1, $0, 0
		bne		 $7, $1, bb_gcd_21
		j bb_gcd_16
	# basicBlock_14
		bb_gcd_14:
		# 	%15 = load i32, i32* %4
		lw		 $5, 16($29)
		# 	store i32 %15, i32* @ans
		sw		 $5, 0($28)
		# 	ret void
		sw		 $5, 52($29)
		jr $31
	# basicBlock_16
		bb_gcd_16:
		# 	%17 = load i32, i32* %3
		lw		 $5, 12($29)
		# 	%18 = load i32, i32* %4
		lw		 $6, 16($29)
		# 	%19 = icmp sge i32 %17, %18
		sge		 $7, $5, $6
		# 	%20 = icmp ne i1 %19, 0
		# 	br i1 %20, label %24, label %29
		addiu	 $1, $0, 0
		bne		 $7, $1, bb_gcd_24
		j bb_gcd_29
	# basicBlock_21
		bb_gcd_21:
		# 	%22 = load i32, i32* %3
		lw		 $5, 12($29)
		# 	store i32 %22, i32* @ans
		sw		 $5, 0($28)
		# 	ret void
		sw		 $5, 72($29)
		jr $31
	# basicBlock_23
		bb_gcd_23:
		# 	ret void
		jr $31
	# basicBlock_24
		bb_gcd_24:
		# 	%25 = load i32, i32* %3
		lw		 $5, 12($29)
		# 	%26 = load i32, i32* %4
		lw		 $6, 16($29)
		# 	%27 = srem i32 %25, %26
		div		 $5, $6
		mfhi	 $7
		# 	%28 = load i32, i32* %4
		lw		 $8, 16($29)
		# 	call void @gcd(i32 %27,i32 %28)
		sw		 $5, 76($29)
		sw		 $6, 80($29)
		sw		 $7, 84($29)
		sw		 $8, 88($29)
		sw		 $31, 0($29)
		sw		 $7, -104($29)
		sw		 $8, -100($29)
		addiu	 $29, $29, -108
		jal f_gcd
		addiu	 $29, $29, 108
		lw		 $31, 0($29)
		# 	br label %23
		j bb_gcd_23
	# basicBlock_29
		bb_gcd_29:
		# 	%30 = load i32, i32* %3
		lw		 $5, 12($29)
		# 	%31 = load i32, i32* %4
		lw		 $6, 16($29)
		# 	%32 = load i32, i32* %3
		lw		 $7, 12($29)
		# 	%33 = srem i32 %31, %32
		div		 $6, $7
		mfhi	 $8
		# 	call void @gcd(i32 %30,i32 %33)
		sw		 $5, 92($29)
		sw		 $6, 96($29)
		sw		 $7, 100($29)
		sw		 $8, 104($29)
		sw		 $31, 0($29)
		sw		 $5, -104($29)
		sw		 $8, -100($29)
		addiu	 $29, $29, -108
		jal f_gcd
		addiu	 $29, $29, 108
		lw		 $31, 0($29)
		# 	br label %23
		j bb_gcd_23

# function_void @output(i32):
		f_output:
	# basicBlock_1
		# 	%2 = alloca i32
		# 	store i32 %0, i32* %2
		lw		 $5, 4($29)
		sw		 $5, 8($29)
		# 	%3 = load i32, i32* %2
		lw		 $6, 8($29)
		la $4, str_0
		addiu	 $2, $0, 4
		syscall
		# 	call void @putint(i32 %3)
		xor		 $4, $6, $0
		addiu	 $2, $0, 1
		syscall
		la $4, str_1
		addiu	 $2, $0, 4
		syscall
		# 	ret void
		sw		 $6, 12($29)
		jr $31

# function_void @error():
		f_error:
	# basicBlock_0
		la $4, str_2
		addiu	 $2, $0, 4
		syscall
		# 	ret void
		jr $31
